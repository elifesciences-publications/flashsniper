;; $READ_LSM.PRO$
;
; Copyright @ Calcium signalling lab, IMM, PKU.
; All rights reserved.
; Kaitaoli@pku.edu.cn
; Unauthorized reproduction prohibited.
;+
; NAME:
;       READ_LSM
;
; PURPOSE:
;       This function reads the *.lsm file generated by ZEISS LSM510.
;
; CATEGORY:
;       FILE INPUT.
;
; CALLING SEQUENCE:
;       Result = READ_LSM( file, channel, imginfo)
;
; INPUTS:
;       file:    the lsm format file to be read.
;
;       channel:    the number of channel to be read, should be a scalar or one dimensional
;                         vector  [1,2,3,...], 0:all channels
;
;		imginfo:    a structure contains the basic information of the image.
;
; MODIFICATION HISTORY:
;       Written by:  Peter Lee, March 2006
;       Modified:    Peter Lee, January 2007
;		Modified:    Peter Lee, October 2007



pro SelectChannel_event, Event

  wTarget = (widget_info(Event.id,/NAME) eq 'TREE' ?  $
      widget_info(Event.id, /tree_root) : event.id)


  wWidget =  Event.top

  case wTarget of
  widget_info(wWidget, find_by_uname='Select All'): begin
    for i=0,(*pL).ChNum-1 do begin
      button = widget_info(wWidget, find_by_uname='channel'+string(i+1,format='(i0)'))
      widget_control, button, set_button=1
    endfor
    (*pL).selection = replicate(1b,(*pL).ChNum)
  end
  widget_info(wWidget, find_by_uname='Disselect All'): begin
    for i=0,(*pL).ChNum-1 do begin
      button = widget_info(wWidget, find_by_uname='channel'+string(i+1,format='(i0)'))
      widget_control, button, set_button=0
    endfor
    (*pL).selection = bytarr((*pL).ChNum)
  end
  widget_info(wWidget, find_by_uname='OK'): begin
    widget_control,event.top,get_uvalue=pL
    for i=0,(*pL).ChNum-1 do begin
      button = widget_info(wWidget, find_by_uname='channel'+string(i+1,format='(i0)'))
      (*pL).selection[i] = widget_info(button, /button_set)
      order = widget_info(wWidget, find_by_uname='order'+string(i+1,format='(i0)'))
      (*pL).order[i] = widget_info(order,/droplist_select)
    endfor
    validCh = where((*pL).selection eq 1)
    if validCh[0] ne -1 then begin
      validChNum = n_elements(validCh)
      if n_elements((*pL).order[validCh]) gt n_elements(uniq((*pL).order[validCh])) then begin
        void = dialog_message('Duplicated orders detected!',/error)
        return
      endif
      for i=0,validChNum-1 do begin
        if (*pL).order[validCh[i]] ge validChNum then begin
          void = dialog_message('Channel order exceeds selected channel number!',/error)
          return
        endif
      endfor
    endif
    widget_control, wWidget, /destroy
  end
  widget_info(wWidget, find_by_uname='Cancel'): begin
    widget_control,event.top,get_uvalue=pL
    widget_control, wWidget, /destroy
    (*pL).selection = bytarr((*pL).ChNum)
  end
    else:
  endcase

end

Function SelectChannel, name, filter, color, laser, preSelection=preSelection, $
                        preOrder=preOrder, GROUP_LEADER=wGroup, _EXTRA=_VWBExtra_

  ChNum = n_elements(name)
  selection = (n_elements(preSelection) ne 0) ? preSelection : bytarr(ChNum)
  order = (n_elements(preOrder)) ? preOrder : indgen(ChNum)

  select_channel_base = keyword_set(wGroup) ? $
  Widget_Base( GROUP_LEADER=wGroup, UNAME='WID_BASE_0'  $
      ,XOFFSET=10 ,YOFFSET=5 ,TITLE='Select Channel' ,SPACE=3, /modal  $
      ,XPAD=10 ,YPAD=10 ,COLUMN=1 ,TLB_FRAME_ATTR=9) : $
  Widget_Base( GROUP_LEADER=wGroup, UNAME='WID_BASE_0'  $
      ,XOFFSET=10 ,YOFFSET=5 ,TITLE='Select Channel' ,SPACE=3  $
      ,XPAD=10 ,YPAD=10 ,COLUMN=1 ,TLB_FRAME_ATTR=9)

  WID_BASE_1 = Widget_Base(select_channel_base, UNAME='WID_BASE_1' ,XOFFSET=10  $
      ,YOFFSET=10 ,SCR_XSIZE=284 ,SCR_YSIZE=25 ,TITLE='IDL' ,SPACE=3  $
      ,XPAD=3 ,YPAD=3)
  WID_LABEL_1 = Widget_Label(WID_BASE_1, UNAME='WID_LABEL_1'  $
      ,XOFFSET=20 ,YOFFSET=7 ,SCR_XSIZE=41 ,SCR_YSIZE=18 ,/ALIGN_LEFT  $
      ,VALUE='Channel')
  WID_LABEL_2 = Widget_Label(WID_BASE_1, UNAME='WID_LABEL_2'  $
      ,XOFFSET=105 ,YOFFSET=7 ,/ALIGN_LEFT ,VALUE='Filter')
  WID_LABEL_3 = Widget_Label(WID_BASE_1, UNAME='WID_LABEL_3'  $
      ,XOFFSET=185 ,YOFFSET=7 ,/ALIGN_LEFT ,VALUE='Color')
  WID_LABEL_4 = Widget_Label(WID_BASE_1, UNAME='WID_LABEL_3'  $
      ,XOFFSET=245 ,YOFFSET=7 ,/ALIGN_LEFT ,VALUE='Order')

for i=0, ChNum-1 do begin
  WID_BASE_2 = Widget_Base(select_channel_base, UNAME='WID_BASE_2' ,XOFFSET=10  $
      ,YOFFSET=33 ,SCR_XSIZE=284 ,SCR_YSIZE=30 ,SPACE=3  $
      ,XPAD=3 ,YPAD=0)
  WID_BASE_3 = Widget_Base(WID_BASE_2, UNAME='WID_BASE_3' ,XOFFSET=10  $
      ,COLUMN=1 ,/NONEXCLUSIVE)
  WID_BUTTON_0 = Widget_Button(WID_BASE_3, UNAME='channel'+string(i+1,format='(i0)')  $
      ,/ALIGN_LEFT ,VALUE=name[i])
  if selection[i] eq 1b then widget_control, wid_button_0, set_button=1
  WID_LABEL_0 = Widget_Label(WID_BASE_2, UNAME='WID_LABEL_0'  $
      ,XOFFSET=90 ,YOFFSET=7 ,/ALIGN_LEFT ,VALUE=filter[i])
  img = bytarr(60,20,3)
  img[*,*,0] += color[0,i] & img[*,*,1] += color[1,i] & img[*,*,2] += color[2,i]
  WID_BUTTON_0 = Widget_BUTTON(WID_BASE_2, UNAME='WID_BUTTON_0'  $
      ,XOFFSET=165 ,YOFFSET=4 ,SCR_XSIZE=60 ,SCR_YSIZE=20, value=img)
  WID_Droplist_0 = Widget_Droplist(WID_BASE_2, UNAME='order'+string(i+1,format='(i0)')  $
      ,XOFFSET=240 ,YOFFSET=5 ,SCR_XSIZE=35 ,SCR_YSIZE=20, value=strtrim(indgen(ChNum)+1,1))
  widget_control,wid_droplist_0,set_droplist_select=i
endfor

WID_BASE_1 = Widget_Base(select_channel_base, UNAME='WID_BASE_1' ,XOFFSET=10  $
      ,YOFFSET=10 ,SCR_XSIZE=284 ,SCR_YSIZE=20 ,SPACE=3  $
      ,XPAD=3 ,YPAD=3)
  WID_LABEL_1 = Widget_Label(WID_BASE_1, UNAME='WID_LABEL_1'  $
      ,XOFFSET=20 ,YOFFSET=5 ,SCR_XSIZE=41 ,SCR_YSIZE=18 ,/ALIGN_LEFT  $
      ,VALUE='Track')
  WID_LABEL_2 = Widget_Label(WID_BASE_1, UNAME='WID_LABEL_2'  $
      ,XOFFSET=100 ,YOFFSET=5 ,/ALIGN_LEFT ,VALUE='Laser Wavelength')
  WID_LABEL_3 = Widget_Label(WID_BASE_1, UNAME='WID_LABEL_3'  $
      ,XOFFSET=225 ,YOFFSET=5 ,/ALIGN_LEFT ,VALUE='Power')

for i=0, n_elements(laser)/3-1 do begin
  WID_BASE_2 = Widget_Base(select_channel_base, UNAME='WID_BASE_2' ,XOFFSET=10  $
      ,YOFFSET=43 ,SCR_XSIZE=284 ,SCR_YSIZE=20 ,SPACE=3  $
      ,XPAD=3 ,YPAD=3)
  WID_LABEL_1 = Widget_Label(WID_BASE_2, UNAME='WID_LABEL_1'  $
      ,XOFFSET=20 ,YOFFSET=5 ,SCR_XSIZE=41 ,SCR_YSIZE=18 ,/ALIGN_LEFT  $
      ,VALUE=laser[0,i])
  WID_LABEL_2 = Widget_Label(WID_BASE_2, UNAME='WID_LABEL_2'  $
      ,XOFFSET=125 ,YOFFSET=5 ,/ALIGN_LEFT ,VALUE=laser[1,i])
  WID_LABEL_3 = Widget_Label(WID_BASE_2, UNAME='WID_LABEL_3'  $
      ,XOFFSET=225 ,YOFFSET=5 ,/ALIGN_LEFT ,VALUE=laser[2,i])
endfor

  WID_BASE_4 = Widget_Base(select_channel_base, UNAME='WID_BASE_4' ,XOFFSET=10  $
      ,YOFFSET=76 ,SCR_XSIZE=284 ,SCR_YSIZE=35 ,TITLE='IDL' ,SPACE=3  $
      ,XPAD=3 ,YPAD=3)
  WID_BUTTON_1 = Widget_Button(WID_BASE_4, UNAME='Select All' ,xsize=65 $
      ,XOFFSET=10 ,YOFFSET=5 ,/ALIGN_CENTER ,VALUE='Select All')
  WID_BUTTON_2 = Widget_Button(WID_BASE_4, UNAME='Disselect All' ,xsize=70 $
      ,XOFFSET=80 ,YOFFSET=5 ,/ALIGN_CENTER ,VALUE='Disselect All')
  WID_BUTTON_3 = Widget_Button(WID_BASE_4, UNAME='OK'  $
      ,XOFFSET=160 ,YOFFSET=5 ,SCR_XSIZE=50 ,SCR_YSIZE=22  $
      ,/ALIGN_CENTER ,VALUE='OK')
  WID_BUTTON_4 = Widget_Button(WID_BASE_4, UNAME='Cancel'  $
      ,XOFFSET=220 ,YOFFSET=5 ,/ALIGN_CENTER ,VALUE='Cancel')

  localState = { ChNum: ChNum, $
        selection: selection, $
        order: order }
  pL = ptr_new(localState,/no_copy)
  Widget_Control, /REALIZE, select_channel_base, set_uvalue=pL
  Widget_Control, WID_BUTTON_3, /input_focus
  XManager, 'SelectChannel', select_channel_base

  localState = *pL
  ptr_free,pL
return, localState
end

Function Widget_Read_LSM, file, channel, imgInfo, auto=auto, group_leader=group_leader

	imgInfo = {imgInfo, scanType:'0', $
			channelNum:0, $
			imgSize:intarr(3), $
			pixelSize:fltarr(3), $
			channelName:ptr_new('',/allocate_heap), $
			channelColor:ptr_new(-1,/allocate_heap), $
			channelFilter:ptr_new('',/allocate_heap), $
			channelSelection:ptr_new('',/allocate_heap), $
			laserInfo:ptr_new('',/allocate_heap), $
			timeStamp:ptr_new(-1,/allocate_heap), $
			vectorOverlay:ptr_new(-1,/allocate_heap), $
			roiOverlay:ptr_new(-1,/allocate_heap) }

	;read tiff header
	header = {lsmHeader, byteOrder:0US, lsmId:0US, offset:0UL}
	openr, lun, file, /get_lun
	readu, lun, header
	if header.lsmId ne 42 then begin
       r = dialog_message("This is not a LSM file.")
       close, lun
       free_lun, lun
       return, ptr_new()
    endif

	;read LSM info
	entry = {entry, tag:0US, type:0US, length:0UL, value:0UL}
	tagNum = 0Us
	point_lun, lun, header.offset
	readu, lun, tagNum
	for i=1, tagNum do begin
		readu, lun, entry
		case entry.tag of
			254: thumbnail = entry.value
	        256: imgWidth = entry.value
	        257: imgLength = entry.value
	        258: bitspersample = entry.value
	        262: photometric = entry.value
	        273: stripoffset = entry.value
	        34412: infoPos = entry.value  ;TIF_CZ_LSMINFO
			else:
		endcase
	endfor
    lsmInfo = { lsminfo,$
       u32MagicNumber: 0UL,$
       s32StructureSize: 0L,$
       s32DimensionX:0L,$
       s32DimensionY:0L,$
       s32DimensionZ:0L,$
       s32DimensionChannels:0L,$
       s32DimensionTime:0L,$
       s32DataType:0L,$
       s32ThumbnailX:0L,$
       s32ThumbnailY:0L,$
       f64VoxelSizeX: 0.0D,$
       f64VoxelSizeY: 0.0D,$
       f64VoxelSizeZ: 0.0D,$
       f64OriginX: 0.0D,$
       f64OriginY: 0.0D,$
       f64OriginZ: 0.0D,$
       u16ScanType: 0US,$
       u16SpectralScan: 0US,$
       u32DataType: 0UL,$
       u32OffsetVectorOverlay: 0UL,$
       u32OffsetInputLut: 0UL,$
       u32OffsetOutputLut: 0UL,$
       u32OffsetChannelColors: 0UL,$
       f64TimeInterval: 0.0D,$
       u32OffsetChannelDataTypes: 0UL,$
       u32OffsetScanInformation: 0UL,$
       u32OffsetKsData: 0UL,$
       u32OffsetTimeStamps: 0UL, $
       u32OffsetEventList: 0UL,$
       u32OffsetRoi: 0UL,$
       u32OffsetBleachRoi: 0UL,$
       u32OffsetNextRecording: 0UL,$
       f64DisplayAspectX: 0.0D,$
       f64DisplayAspectY: 0.0D,$
       f64DisplayAspectZ: 0.0D,$
       f64DisplayAspectTime: 0.0D,$
       u32OffsetMeanOfRoisOverlay: 0UL,$
       u32OffsetTopoIsolineOverlay: 0UL,$
       u32OffsetTopoProfileOverlay: 0UL,$
       u32OffsetLinescanOverlay: 0UL,$
       u32ToolbarFlags: 0UL,$
       u32OffsetChannelWavelength: 0UL,$
       u32Reserved: ulonarr(76) }

	point_lun, lun, infoPos
	readu, lun, lsmInfo
;	print,lsminfo.u32OffsetChannelWavelength
;	retall

	pixelSize_x = lsmInfo.f64VoxelSizeX * 1e+6
	pixelSize_y = lsmInfo.f64VoxelSizeY * 1e+6
	scanType = lsmInfo.u16ScanType
	channelNum = lsminfo.s32DimensionChannels
	if channelNum gt 1 then begin
		point_lun, lun, bitspersample
		bitspersample = uintarr(channelNum)
		readu, lun, bitspersample
	endif

	;read time stamps
	if lsmInfo.u32OffsetTimeStamps eq 0 then begin
		imgInfo.timeStamp = ptr_new([0])
		pixelSize_t = 0
	endif else begin
		stampSize = 0L
		stampNum = 0L
		point_lun, lun, lsmInfo.u32OffsetTimeStamps
		readu, lun, stampSize, stampNum
		timeStamp = dblarr(stampNum)
		readu, lun, timeStamp
		imgInfo.timeStamp = ptr_new(timeStamp)
		t0 = timeStamp[0]
		timeStamp -= t0
		timeStamp *= 1e+3
		pixelSize_t = (lsmInfo.s32DimensionTime gt 1) ? $
		  (timeStamp[lsmInfo.s32DimensionTime-1]-timeStamp[0])/(lsmInfo.s32DimensionTime-1) : 1
	endelse

	imgInfo.scanType = scanType
	imgInfo.channelNum = channelNum
	imgInfo.pixelSize = [pixelSize_x, pixelSize_y, pixelSize_t]
	channel = (channel >0) < channelNum

	;read channel names and colors
	channelInfoSize = 0L & colorNum = 0L & nameNum = 0L
	colorOffset = 0L & nameOffset = 0L
	point_lun, lun, lsminfo.u32OffsetChannelColors
	readu, lun, channelInfoSize, colorNum, nameNum, colorOffset, nameOffset
	;print, colorNum, nameNum
	point_lun, lun, lsminfo.u32OffsetChannelColors+colorOffset
	color = bytarr(4) & colorArray = bytarr(4,channelNum)
	for i=0, channelNum-1 do begin
		readu, lun, color  ;& print, color
		colorArray[*,i] = color
	endfor
	imgInfo.channelColor = ptr_new(colorArray)
	point_lun, lun, lsminfo.u32OffsetChannelColors+nameOffset
	imgInfo.channelName = ptr_new(strarr(channelNum))
	nameByte = byte(1) & name = '' & count=0
	for i=0,channelInfoSize-nameOffset-1 do begin
		readu, lun, nameByte ;& print,string(nameByte)
		if nameByte gt 40B then begin
			if name[0] eq '' then name = string(nameByte) else name = strjoin([name, string(nameByte)])
		endif else begin
			if name[0] eq '' then continue else begin
				if count lt channelNum then (*imgInfo.channelName)[count] = name ;& print,name
				count++
				name = ''
			endelse
		endelse
	endfor
;	print, *imgInfo.channelColor
;	print, *imgInfo.channelName

	; read channel filters
	blockEntry = 0UL & blockType = 0UL & blockSize = 0UL
	pos = lsmInfo.u32OffsetScanInformation ;& print,pos, lsmInfo.u32OffsetChannelColors
	step = 0
	scanInfo = '' & laserInfo = '' & track_switch = 0b & trackNUm = 0
	while pos lt lsmInfo.u32OffsetScanInformation+20000 do begin
;		if channelNum eq 1 then track_switch=1
		point_lun, lun, pos
		readu, lun, blockEntry, blockType, blockSize
		step++
		case blockEntry of
		1073741830: begin
			aquire = 0UL
			readu, lun, aquire
			track_switch = (aquire ne 0) ? 1b : 0b
			end
		1073741836: begin    ; track name on Track
			name = bytarr(blockSize)
			readu, lun, name  ;& print, string(name)
			if strpos(string(name), 'Ratio') ne -1 or strpos(string(name), 'Bleach') ne -1 then track_switch = 0b
			if strpos(string(name), 'Track') ne -1 then trackNum++
			if	track_switch eq 1b then begin
				scanInfo = [scanInfo, 'Start'+strtrim(string(trackNum),1), string(name)]
				laserInfo = [laserInfo, 'Start'+strtrim(string(trackNum),1), string(name)]
			endif
			end
		1879048208: begin    ; filter name on Detection Channel
			name = bytarr(blockSize)
			readu, lun, name ;& print, string(name)
			if track_switch eq 1b then scanInfo = [scanInfo, string(name)]
			end
		1879048212: begin    ; channel name on Detection Channel
			name = bytarr(blockSize)
			readu, lun, name ; & print, string(name)
			if track_switch eq 1b and string(name) ne 'ChD' then scanInfo = [scanInfo, string(name)]
			end
		2415919105: begin    ; illumination channel name
			name = bytarr(blockSize)
			readu, lun, name  ;& print, string(name)
			if track_switch eq 1b then laserInfo = [laserInfo, string(name)]
			end
		2415919106: begin    ; laser power
			power = 0D
			readu, lun, power  ;& print, power
			if track_switch eq 1b then laserInfo = [laserInfo, string(power, format='(f0.1)')]
			end
		2415919108: begin    ; laser aquirement
			aquire = 0UL
			readu, lun, aquire  ;& print, aquire
			if track_switch eq 1b then laserInfo = [laserInfo, string(aquire, format='(i0)')]
			end
		285212672: break  ; timers
		301989888: break  ; timer
		318767104: break  ; markers
		335544320: break  ; marker
		else:
		endcase
		pos += 12+blockSize
	endwhile
	;print, scanInfo, laserInfo
	imgInfo.channelFilter = ptr_new(strarr(channelNum))
	start1 = where(scanInfo eq 'Start1') & start2 = where(scanInfo eq 'Start2')
	track1Pos = start1[0]+1 & track2Pos = start2[0]+1
	track1Start = track1Pos +1 & track1End = (start2[0] eq -1) ? n_elements(scanInfo)-1 : start2[0]-1
	for i=track1Start, track1End do begin
		if strpos(scanInfo[i], 'Ch') ne -1 and scanInfo[i] ne 'ChD' then begin
			filter = scanInfo[i-1]
			for k=0, channelNum-1 do begin
				if strpos((*imgInfo.channelName)[k], scanInfo[i]) eq -1 or strpos((*imgInfo.channelName)[k], 'T1') eq -1 $
				then continue else (*imgInfo.channelFilter)[k] = filter ;& print, scanInfo[i], filter
			endfor
		endif
	endfor
	if start2[0] ne -1 then begin   ; two track
		track2Start = track2Pos + 1 & track2End = n_elements(scanInfo)-1
		for i=track2Start, track2End do begin
			if strpos(scanInfo[i], 'Ch') ne -1 and scanInfo[i] ne 'ChD' then begin
				filter = scanInfo[i-1]
				for k=0, channelNum-1 do begin
					if strpos((*imgInfo.channelName)[k], scanInfo[i]) eq -1 or strpos((*imgInfo.channelName)[k], 'T2') eq -1 $
					then continue else (*imgInfo.channelFilter)[k] = filter ;& print, scanInfo[i], filter
				endfor
			endif
		endfor
	endif
;	print, *imgInfo.channelFilter

	start1 = where(laserInfo eq 'Start1') & start2 = where(laserInfo eq 'Start2')
	track1Pos = start1[0]+1 & track2Pos = start2[0]+1
	track1Start = track1Pos +1 & track1End = (start2[0] eq -1) ? n_elements(laserInfo)-1 : start2[0]-1
	for i=1, (track1End-track1Start+1)/3 do begin
		if laserInfo[track1Pos+i*3] ne '0' then begin
			if n_elements(laser) eq 0 then begin
				laser = ['Track1', laserInfo[track1Pos+i*3-2]+'nm', laserInfo[track1Pos+i*3-1]+'%']
			endif else laser = [[laser],['Track1', laserInfo[track1Pos+i*3-2]+'nm', laserInfo[track1Pos+i*3-1]+'%']]
		endif
	endfor
	if start2[0] ne -1 then begin   ; two track
		track2Start = track2Pos + 1 & track2End = n_elements(laserInfo)-1
		for i=1, (track2End-track2Start+1)/3 do begin
			if laserInfo[track2Pos+i*3] ne '0' then begin
				if n_elements(laser) eq 0 then begin
					laser = ['Track2', laserInfo[track2Pos+i*3-2]+'nm', laserInfo[track2Pos+i*3-1]+'%']
				endif else laser = [[laser],['Track2', laserInfo[track2Pos+i*3-2]+'nm', laserInfo[track2Pos+i*3-1]+'%']]
			endif
		endfor
	endif
	;print, laser
	imgInfo.laserInfo = ptr_new(laser, /no_copy)

; ------------------------------- channel selection ----------------------------------
	if channel[0] eq 0 then preSelection = replicate(1b,channelNum) $
	else begin
		preSelection = bytarr(channelNum)
		preSelection[(channel > 1) < channelNum -1] = 1b
	endelse
	preOrder = intarr(channelNum)
	for i=0,channelNum-1 do preOrder[i]=total(preSelection[0:i])
	preOrder = (preOrder-1)*preSelection

	if keyword_set(auto) then begin
	  selection = preSelection
	  order = preOrder
	endif else begin
	  ChOpt =	(keyword_set(group_leader) ? $
		SelectChannel(*imgInfo.channelName,*imgInfo.channelFilter,*imgInfo.channelColor, *imgInfo.laserInfo, $
							preSelection=preSelection, preOrder=preOrder, group_leader=group_leader) : $
		SelectChannel(*imgInfo.channelName,*imgInfo.channelFilter,*imgInfo.channelColor, *imgInfo.laserInfo, $
							preSelection=preSelection,preOrder=preOrder))
		selection = ChOpt.selection
		if max(selection) eq 0 then return, ptr_new()
		if max(ChOpt.order-preOrder) ne 0 then begin
		  newChannelColor = *imgInfo.channelColor
		  for i=0,channelNum-1 do begin
		    if selection[i] eq 0 then (*imgInfo.channelcolor)[*,i] = [0b,0b,0b,0b] $
		    else begin
		      (*imgInfo.channelcolor)[*,ChOpt.order[i]] = newChannelColor[*,i]
		    endelse
		  endfor
		endif
		order = ChOpt.order
  endelse
	channel = where(selection eq 1b, validChNum) + 1
	if validChNum le 0 then return,ptr_new()
	imgInfo.channelSelection = ptr_new(selection)
;	retall

;--------------------------------- read vector overlay ---------------------------------
;	if lsmInfo.u32OffsetVectorOverlay ne 0 then begin
;		drawNum = 0L
;		point_lun, lun, lsmInfo.u32OffsetVectorOverlay
;		readu, lun, drawNum
;		if drawNum gt 0 then begin
;			*imgInfo.vectorOverlay = fltarr(4,drawNum)
;			x1 = 0D & y1 = 0D & x2 = 0D & y2 = 0D
;			point_lun, -lun, pos & point_lun, lun, pos+192
;			for i=0,drawNum-1 do begin
;				drawType = 1L
;	            readu, lun, drawType
;	            if drawType eq 18 then begin
;	            	point_lun, -lun, pos & point_lun, lun, pos+204
;					readu, lun, x1,y1,x2,y2
;					if x1 gt x2 then swap_var,x1,x2
;					if y1 gt y2 then swap_var,y1,y2
;					(*imgInfo.vectorOverlay)[*,i] = [x1,y1,x2,y2]
;				endif else begin
;		            drawSize = 1L
;		            readu, Lun, drawSize
;		            point_lun, lun, pos+190+drawSize
;	           endelse
;			endfor
;		endif
;	endif


;--------------------------------- read ROI overlay ---------------------------------
;	if lsmInfo.u32OffsetMeanOfRoisOverlay ne 0 then begin
;		drawNum = 0L
;		point_lun, lun, lsmInfo.u32OffsetMeanOfRoisOverlay
;		readu, lun, drawNum
;		if drawNum gt 0 then begin
;			*imgInfo.RoiOverlay = fltarr(4,drawNum)
;			x1 = 0D & y1 = 0D & x2 = 0D & y2 = 0D
;			point_lun, -lun, pos & point_lun, lun, pos+192
;			for i=0,drawNum-1 do begin
;				drawType = 1L
;	            readu, lun, drawType
;	            if drawType eq 18 then begin
;	            	point_lun, -lun, pos & point_lun, lun, pos+204
;					readu, lun, x1,y1,x2,y2
;					if x1 gt x2 then swap_var,x1,x2
;					if y1 gt y2 then swap_var,y1,y2
;					(*imgInfo.roiOverlay)[*,i] = [x1,y1,x2,y2]
;				endif else begin
;		            drawSize = 1L
;		            readu, Lun, drawSize
;		            point_lun, lun, pos+190+drawSize
;	           endelse
;			endfor
;		endif
;	endif

	;read image data
	;-------------------------- read line scan image --------------------------
	if scanType eq 2 || scanType eq 7 then begin
;		print,'This is a linescan image.'
		imgInfo.scanType = 'linescan'
		size_x = imgWidth
		size_y = imgWidth
		size_t = imgLength
		imgInfo.imgSize = [size_x, size_y, size_t]

		point_lun, lun, header.offset
		readu, lun, tagNum
		for i=1,tagNum do begin
			readu, lun, entry
			if entry.tag eq 254 then thumbNail = entry.value
			if entry.tag eq 273 then begin
				stripoffset = entry.value
				break
			endif
		endfor

		if channelNum eq 1 then begin    ;signal channel
			if bitsperSample eq 8 then ima = bytarr(size_x, size_t) $
			else ima = intarr(size_x, size_t)
			point_lun, lun, stripOffset
			readu, lun, ima
			image = PTR_NEW(reverse(ima,1))
		endif else begin                 ;multiple channel
			point_lun, lun, stripOffset
			stripOffset = ulonarr(channelNum)
			readu, lun, stripOffset
			image = PTRARR(validChNum, /allocate_heap)
			for i=0, validChNum-1 do begin
				if bitsperSample[i] eq 8 then *image[i] = bytarr(size_x, size_t) $
				else *image[i] = intarr(size_x, size_t)
				point_lun, lun, stripOffset[channel[i]-1]
				readu, lun, ima
				*image[order[channel[i]-1]] = reverse(ima,1)
			endfor
		endelse
	endif


	;----------------------------- read series xy image ----------------------------------
	if scanType eq 0 or scanType eq 3 then begin
;		print,'This is a series surface-scan image.'
		imgInfo.scanType = 'surfacescan'
		size_x = imgWidth
		size_y = imgLength
		size_t = lsmInfo.s32DimensionTime
		imgInfo.imgSize = [size_x, size_y, size_t]

		if channelNum eq 1 then begin     ;signal channel
			if bitsperSample eq 8 then begin
				ima = bytarr(size_x, size_y)
				image = PTR_NEW(bytarr(size_x, size_y, size_t), /no_copy)
			endif else begin
				ima = intarr(size_x, size_y)
				image = PTR_NEW(intarr(size_x, size_y, size_t), /no_copy)
			endelse
			pos = header.offset
			dirNum = 0
			while pos ne 0 do begin
				point_lun, lun, pos
				readu, lun, tagNum
				for i=1, tagNum do begin
					readu, lun, entry
					if entry.tag eq 254 then thumbNail = entry.value
					if entry.tag eq 273 then stripOffset = entry.value
				endfor
				readu, lun, pos
				if thumbNail eq 0 then begin
					point_lun, lun, stripOffset
					readu, lun, ima
					(*image)[0,0,dirNum] = reverse(ima,2)
					dirNum++
				endif
			endwhile
		endif else begin           ;multiple channel
			image = PTRARR(validChNum)
			for i=0, validChNum-1 do begin
				if bitsperSample[i] eq 8 then begin
					ima = bytarr(size_x, size_y)
					image[i] = PTR_NEW(bytarr(size_x, size_y, size_t), /no_copy)
				endif else begin
					ima = intarr(size_x, size_y)
					image[i] = PTR_NEW(intarr(size_x, size_y, size_t), /no_copy)
				endelse
			endfor
			pos = header.offset
			dirNum = 0
			while pos ne 0 do begin
				point_lun, lun, pos
				readu, lun, tagNum
				for i=1, tagNum do begin
					readu, lun, entry
					if entry.tag eq 254 then thumbNail = entry.value
					if entry.tag eq 273 then stripOffset = entry.value
				endfor
				readu, lun, pos
				if thumbNail eq 0 then begin
					point_lun, lun, stripOffset
					stripOffset = ulonarr(channelNum)
					readu, lun, stripOffset
					for i=0,validChNum-1 do begin
						point_lun, lun, stripOffset[channel[i]-1]
						readu, lun, ima
						(*image[order[channel[i]-1]])[0,0,dirNum] = reverse(ima,2)
					endfor
					dirNum++
				endif
			endwhile
		endelse
	endif

free_lun, lun
return, image

End
